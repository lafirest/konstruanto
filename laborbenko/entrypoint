#!/bin/bash

set -e

## update window name
echo -ne "\033]0; $(hostname) \007"

#ETC_DIR=etc
ETC_DIR=/etc/laborbenko
RETRY=3
ENV=CCACHE_DIR,http_proxy,https_proxy,TZ,BASH_FUNC_set-env%%
_HEJMO="/home/firest"
_PROFILO="$_HEJMO/.profile"
_RC="$_HEJMO/.bashrc"
_UZANTO="firest"

function run_as {
    cd $_HEJMO
    BASH_ENV="$_PROFILO" runuser -s /bin/bash "$_UZANTO" -c "$*"
}

export -f run_as

function run_in {
    local dir="$1"
    shift;
    cd $_HEJMO
    cd $dir
    BASH_ENV="$_PROFILO" runuser -s /bin/bash "$_UZANTO" -c "$*"
}

export -f run_in

function apt {
 ##  command apt -o Acquire::http::proxy=false \
    command apt -o APT::Install-Recommends=false \
                -o APT::Install-Suggests=false \
                "$@"
}

function load_layer {
    exec_cmds "$1" "$ETC_DIR/$1"
}

function clone {
    local dir="$1"
    local repo="$2"
    cd $_HEJMO
    rm -rf "$dir"
    git clone --depth 1 "$repo"
    cd "$dir"
    git config remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'
}

export -f clone

function set-env {
    local name=$1
    local value="$2"
    export "$name"="$value"
    run_as "export $name=$value"
    ## for login
    run_as "echo export $name=$value >> $_PROFILO"
    ## for non-login
    run_as "echo export $name=$value >> $_RC"
}

export -f set-env

function clean-tmp {
    apt clean
    apt autoremove --yes
    rm -rf /tmp/*
    rm -rf /var/lib/apt/lists/*
    find /var | grep '\.log$' | xargs rm -v
}

function init-rsync {
    local repo="$1"
    echo rsync --daemon >> $(which autostart)
    cat << EOF  > /etc/rsyncd.conf
uid = firest
gid = firest
port = 12000
use chroot = no

pid file = /var/run/rsyncd.pid
lock file = /var/run/rsync.lock
log file = /var/log/rsync.log

[$repo]
        path = $_HEJMO/$repo
        read only = no
        timeout = 300
        fake user = yes
        exclude = _build .git
EOF
}

export -f init-rsync

# automatically retry N times after failure
function with_retry {
    local i=0
    local result=0
    local cmd="$1"
    echo "$cmd"
    while true
    do
        set +e
        eval "$cmd"
        result=$?
        set -e

        [ $result -eq 0 ] && return 0
        [ $i -ge $RETRY ] && echo "Automatic installation failed, enter manual mode" && exec bash

        i=$(( i+1 ))
        local sleep=$(( i * 3))
        printf "Execute failed,retry:%d,sleep:%d\ncommand:%s\n" $i $sleep "$cmd"
        sleep $sleep
    done
}

# recoverable init script
function recoverable_exec_cmds {
    local index=0
    local layer=$1
    shift;
    local cmds=("$@")
    local cursor="$ETC_DIR/cursor_$layer"
    local len=${#cmds[@]}

    ## find the last succeeded index of commands
    if [[ -f $cursor ]]; then
        index=$(( $(cat "$cursor") + 1 ))
    else
        echo -1 > "$cursor"
        chmod 666 "$cursor"
    fi

    # this index must be local or its value will incorrectly be updated by the sub `load_layer` function
    # which is called by the eval and the wrong value will be inherited by the parent function, which leads to this eval loop breaking
    local i=$index
    for (( ; i<len; i++ ))
    do
        local cmd="${cmds[$i]}"
        with_retry "$cmd"
        echo $i > "$cursor"
    done
}

function exec_cmds {
    local layer=$1
    local file=$2
    local cmds=( )

    ## if there is a valid layer, load it
    ## otherwise, treat this script as a login process
    ## and override the IS_BUILD value or the container will immediately exit
    if [ -n "$file" ]; then
        # no readarry in Mac
        while IFS='' read -r line; do
            cmds+=( "$line" )
        done < "$file"
    else
        IS_BUILD=0
        return 0
    fi

    recoverable_exec_cmds "$layer" "${cmds[@]}"
}

while getopts “l:e:b:” argv
do
     case $argv in
         l)
             LAYER=$OPTARG
             ;;
         e)
             EVAL="$OPTARG"
             ;;
         b)
             IS_BUILD=$OPTARG
             ;;
         ?)
         ;;
     esac
done

[ -n "$LAYER" ] && [ "init" != "$LAYER" ] && exec_cmds "$LAYER" "$ETC_DIR/$LAYER"

## eval is always executed at the last for load some customized instructions
if [ -n "$EVAL" ]; then
    echo "eval:$EVAL"
    while read -d ";" -r cmd; do
        with_retry "$cmd"
    done <<< "$EVAL"
fi

if $IS_BUILD; then
    exit 0
fi

autostart
exec su -w $ENV -s /bin/bash - firest
